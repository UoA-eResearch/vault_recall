#!/usr/bin/env python3

from glob import glob
from tqdm import tqdm
import pandas as pd # CSV operations
import sys
import time
import os
import argparse

parser = argparse.ArgumentParser(description='Check vault/archive status by file')

# Pass a text file containing files as the first argument. Such as one generated by:
# find . -type f > filelist.txt
parser.add_argument('-f', '--filelist', help='a text file containing files to check')
parser.add_argument('-v', '--verbose', action='store_true', help='print status for each file to console')

args = parser.parse_args()

try:
    # Read prior recall status results, if they exist
    df = pd.read_csv("~/recall_progress.csv")
except:
    df = pd.DataFrame()

if args.filelist:
    files = list(pd.read_table(args.filelist, header=None).iloc[:, 0])
else:
    # If the user doesn't specify which files to check recall status for, just go get updated status for the existing files known in recall_progress.csv
    files = df.filepath.unique()

print(f"Checking {len(files)} files")

rows = []
for f in tqdm(files):
    stat = os.stat(f)
    current_size_bytes = stat.st_blocks * 512
    actual_size_bytes = stat.st_size
    if args.verbose:
        try:
            pct = round(current_size_bytes/actual_size_bytes*100, 2)
        except ZeroDivisionError:
            pct = 100
        print(f"{f}: {current_size_bytes/1000/1000}MB / {actual_size_bytes/1000/1000}MB ({pct}%)")
    rows.append({
        "filepath": f,
        "timestamp": pd.Timestamp.now(),
        "current_size_bytes": current_size_bytes,
        "actual_size_bytes": actual_size_bytes,
        "atime": stat.st_atime,
        "mtime": stat.st_mtime,
        "ctime": stat.st_ctime
    })
df.append(rows).to_csv("~/recall_progress.csv", index=False)
